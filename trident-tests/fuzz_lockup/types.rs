//! # Trident Generated Types
//!
//! This file is automatically generated by Trident.
//! **DO NOT EDIT THIS FILE MANUALLY**

#![allow(dead_code)]
#![allow(unused_imports)]

use borsh::{BorshDeserialize, BorshSerialize};
use trident_fuzz::fuzzing::*;

// ============================================================================
// PROGRAM MODULES
// ============================================================================

// ----------------------------------------------------------------------------
// Program: sablier_lockup
// ----------------------------------------------------------------------------
pub mod sablier_lockup {
    use super::*;

    // ------------------------------------------------------------------------
    // Program ID
    // ------------------------------------------------------------------------

    /// Returns the program ID for sablier_lockup
    pub fn program_id() -> Pubkey {
        pubkey!("Hs1cF7Xr8XZMsKJCgZt2npNBr83iBqrNiAfZoeVYXA2F")
    }

    // ------------------------------------------------------------------------
    // Instructions
    // ------------------------------------------------------------------------

    // ....................................................................
    // Instruction: Cancel
    // ....................................................................

    /// Main instruction struct for Cancel
    pub struct CancelInstruction {
        pub accounts: CancelInstructionAccountMetas,
        pub data: CancelInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for Cancel instruction
    #[derive(Debug, Clone, Default)]
    pub struct CancelInstructionAccountMetas {
        pub sender: AccountMeta,

        pub sender_ata: AccountMeta,

        pub deposited_token_mint: AccountMeta,

        pub stream_data: AccountMeta,

        pub stream_data_ata: AccountMeta,

        pub stream_nft_mint: AccountMeta,

        pub associated_token_program: AccountMeta,

        pub deposited_token_program: AccountMeta,

        pub system_program: AccountMeta,
    }

    /// Account pubkeys for Cancel instruction
    #[derive(Debug, Clone)]
    pub struct CancelInstructionAccounts {
        pub sender: Pubkey,

        pub sender_ata: Pubkey,

        pub deposited_token_mint: Pubkey,

        pub stream_data: Pubkey,

        pub stream_data_ata: Pubkey,

        pub stream_nft_mint: Pubkey,

        pub deposited_token_program: Pubkey,
    }

    impl CancelInstructionAccounts {
        pub fn new(
            sender: Pubkey,

            sender_ata: Pubkey,

            deposited_token_mint: Pubkey,

            stream_data: Pubkey,

            stream_data_ata: Pubkey,

            stream_nft_mint: Pubkey,

            deposited_token_program: Pubkey,
        ) -> Self {
            Self {
                sender,

                sender_ata,

                deposited_token_mint,

                stream_data,

                stream_data_ata,

                stream_nft_mint,

                deposited_token_program,
            }
        }
    }

    /// Instruction data for Cancel
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct CancelInstructionData {}

    impl CancelInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for CancelInstruction
    impl CancelInstruction {
        fn discriminator() -> [u8; 8] {
            [232u8, 219u8, 223u8, 41u8, 219u8, 236u8, 220u8, 190u8]
        }

        pub fn data(data: CancelInstructionData) -> Self {
            Self {
                accounts: CancelInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: CancelInstructionAccounts) -> Self {
            self.accounts.sender = AccountMeta::new(accounts.sender, true);

            self.accounts.sender_ata = AccountMeta::new(accounts.sender_ata, false);

            self.accounts.deposited_token_mint = AccountMeta::new_readonly(accounts.deposited_token_mint, false);

            self.accounts.stream_data = AccountMeta::new(accounts.stream_data, false);

            self.accounts.stream_data_ata = AccountMeta::new(accounts.stream_data_ata, false);

            self.accounts.stream_nft_mint = AccountMeta::new_readonly(accounts.stream_nft_mint, false);

            self.accounts.associated_token_program =
                AccountMeta::new_readonly(pubkey!("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"), false);

            self.accounts.deposited_token_program = AccountMeta::new_readonly(accounts.deposited_token_program, false);

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.sender.clone());

            metas.push(self.accounts.sender_ata.clone());

            metas.push(self.accounts.deposited_token_mint.clone());

            metas.push(self.accounts.stream_data.clone());

            metas.push(self.accounts.stream_data_ata.clone());

            metas.push(self.accounts.stream_nft_mint.clone());

            metas.push(self.accounts.associated_token_program.clone());

            metas.push(self.accounts.deposited_token_program.clone());

            metas.push(self.accounts.system_program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: CollectFees
    // ....................................................................

    /// Main instruction struct for CollectFees
    pub struct CollectFeesInstruction {
        pub accounts: CollectFeesInstructionAccountMetas,
        pub data: CollectFeesInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for CollectFees instruction
    #[derive(Debug, Clone, Default)]
    pub struct CollectFeesInstructionAccountMetas {
        pub fee_collector: AccountMeta,

        pub fee_recipient: AccountMeta,

        pub treasury: AccountMeta,
    }

    /// Account pubkeys for CollectFees instruction
    #[derive(Debug, Clone)]
    pub struct CollectFeesInstructionAccounts {
        pub fee_collector: Pubkey,

        pub fee_recipient: Pubkey,

        pub treasury: Pubkey,
    }

    impl CollectFeesInstructionAccounts {
        pub fn new(fee_collector: Pubkey, fee_recipient: Pubkey, treasury: Pubkey) -> Self {
            Self {
                fee_collector,

                fee_recipient,

                treasury,
            }
        }
    }

    /// Instruction data for CollectFees
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct CollectFeesInstructionData {}

    impl CollectFeesInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for CollectFeesInstruction
    impl CollectFeesInstruction {
        fn discriminator() -> [u8; 8] {
            [164u8, 152u8, 207u8, 99u8, 30u8, 186u8, 19u8, 182u8]
        }

        pub fn data(data: CollectFeesInstructionData) -> Self {
            Self {
                accounts: CollectFeesInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: CollectFeesInstructionAccounts) -> Self {
            self.accounts.fee_collector = AccountMeta::new_readonly(accounts.fee_collector, true);

            self.accounts.fee_recipient = AccountMeta::new(accounts.fee_recipient, false);

            self.accounts.treasury = AccountMeta::new(accounts.treasury, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.fee_collector.clone());

            metas.push(self.accounts.fee_recipient.clone());

            metas.push(self.accounts.treasury.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: CreateWithDurationsLl
    // ....................................................................

    /// Main instruction struct for CreateWithDurationsLl
    pub struct CreateWithDurationsLlInstruction {
        pub accounts: CreateWithDurationsLlInstructionAccountMetas,
        pub data: CreateWithDurationsLlInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for CreateWithDurationsLl instruction
    #[derive(Debug, Clone, Default)]
    pub struct CreateWithDurationsLlInstructionAccountMetas {
        pub creator: AccountMeta,

        pub creator_ata: AccountMeta,

        pub recipient: AccountMeta,

        pub sender: AccountMeta,

        pub nft_collection_data: AccountMeta,

        pub nft_collection_master_edition: AccountMeta,

        pub nft_collection_metadata: AccountMeta,

        pub nft_collection_mint: AccountMeta,

        pub deposit_token_mint: AccountMeta,

        pub stream_nft_mint: AccountMeta,

        pub recipient_stream_nft_ata: AccountMeta,

        pub stream_data: AccountMeta,

        pub stream_data_ata: AccountMeta,

        pub stream_nft_master_edition: AccountMeta,

        pub stream_nft_metadata: AccountMeta,

        pub associated_token_program: AccountMeta,

        pub deposit_token_program: AccountMeta,

        pub nft_token_program: AccountMeta,

        pub token_metadata_program: AccountMeta,

        pub system_program: AccountMeta,

        pub rent: AccountMeta,
    }

    /// Account pubkeys for CreateWithDurationsLl instruction
    #[derive(Debug, Clone)]
    pub struct CreateWithDurationsLlInstructionAccounts {
        pub creator: Pubkey,

        pub creator_ata: Pubkey,

        pub recipient: Pubkey,

        pub sender: Pubkey,

        pub nft_collection_data: Pubkey,

        pub nft_collection_master_edition: Pubkey,

        pub nft_collection_metadata: Pubkey,

        pub nft_collection_mint: Pubkey,

        pub deposit_token_mint: Pubkey,

        pub stream_nft_mint: Pubkey,

        pub recipient_stream_nft_ata: Pubkey,

        pub stream_data: Pubkey,

        pub stream_data_ata: Pubkey,

        pub stream_nft_master_edition: Pubkey,

        pub stream_nft_metadata: Pubkey,

        pub deposit_token_program: Pubkey,

        pub nft_token_program: Pubkey,
    }

    impl CreateWithDurationsLlInstructionAccounts {
        pub fn new(
            creator: Pubkey,

            creator_ata: Pubkey,

            recipient: Pubkey,

            sender: Pubkey,

            nft_collection_data: Pubkey,

            nft_collection_master_edition: Pubkey,

            nft_collection_metadata: Pubkey,

            nft_collection_mint: Pubkey,

            deposit_token_mint: Pubkey,

            stream_nft_mint: Pubkey,

            recipient_stream_nft_ata: Pubkey,

            stream_data: Pubkey,

            stream_data_ata: Pubkey,

            stream_nft_master_edition: Pubkey,

            stream_nft_metadata: Pubkey,

            deposit_token_program: Pubkey,

            nft_token_program: Pubkey,
        ) -> Self {
            Self {
                creator,

                creator_ata,

                recipient,

                sender,

                nft_collection_data,

                nft_collection_master_edition,

                nft_collection_metadata,

                nft_collection_mint,

                deposit_token_mint,

                stream_nft_mint,

                recipient_stream_nft_ata,

                stream_data,

                stream_data_ata,

                stream_nft_master_edition,

                stream_nft_metadata,

                deposit_token_program,

                nft_token_program,
            }
        }
    }

    /// Instruction data for CreateWithDurationsLl
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct CreateWithDurationsLlInstructionData {
        pub salt: u128,

        pub deposit_amount: u64,

        pub cliff_duration: u64,

        pub total_duration: u64,

        pub start_unlock_amount: u64,

        pub cliff_unlock_amount: u64,

        pub is_cancelable: bool,
    }

    impl CreateWithDurationsLlInstructionData {
        pub fn new(
            salt: u128,

            deposit_amount: u64,

            cliff_duration: u64,

            total_duration: u64,

            start_unlock_amount: u64,

            cliff_unlock_amount: u64,

            is_cancelable: bool,
        ) -> Self {
            Self {
                salt,

                deposit_amount,

                cliff_duration,

                total_duration,

                start_unlock_amount,

                cliff_unlock_amount,

                is_cancelable,
            }
        }
    }

    /// Implementation for CreateWithDurationsLlInstruction
    impl CreateWithDurationsLlInstruction {
        fn discriminator() -> [u8; 8] {
            [87u8, 17u8, 170u8, 167u8, 156u8, 152u8, 169u8, 61u8]
        }

        pub fn data(data: CreateWithDurationsLlInstructionData) -> Self {
            Self {
                accounts: CreateWithDurationsLlInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: CreateWithDurationsLlInstructionAccounts) -> Self {
            self.accounts.creator = AccountMeta::new(accounts.creator, true);

            self.accounts.creator_ata = AccountMeta::new(accounts.creator_ata, false);

            self.accounts.recipient = AccountMeta::new_readonly(accounts.recipient, false);

            self.accounts.sender = AccountMeta::new_readonly(accounts.sender, false);

            self.accounts.nft_collection_data = AccountMeta::new(accounts.nft_collection_data, false);

            self.accounts.nft_collection_master_edition =
                AccountMeta::new_readonly(accounts.nft_collection_master_edition, false);

            self.accounts.nft_collection_metadata = AccountMeta::new(accounts.nft_collection_metadata, false);

            self.accounts.nft_collection_mint = AccountMeta::new_readonly(accounts.nft_collection_mint, false);

            self.accounts.deposit_token_mint = AccountMeta::new_readonly(accounts.deposit_token_mint, false);

            self.accounts.stream_nft_mint = AccountMeta::new(accounts.stream_nft_mint, false);

            self.accounts.recipient_stream_nft_ata = AccountMeta::new(accounts.recipient_stream_nft_ata, false);

            self.accounts.stream_data = AccountMeta::new(accounts.stream_data, false);

            self.accounts.stream_data_ata = AccountMeta::new(accounts.stream_data_ata, false);

            self.accounts.stream_nft_master_edition = AccountMeta::new(accounts.stream_nft_master_edition, false);

            self.accounts.stream_nft_metadata = AccountMeta::new(accounts.stream_nft_metadata, false);

            self.accounts.associated_token_program =
                AccountMeta::new_readonly(pubkey!("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"), false);

            self.accounts.deposit_token_program = AccountMeta::new_readonly(accounts.deposit_token_program, false);

            self.accounts.nft_token_program = AccountMeta::new_readonly(accounts.nft_token_program, false);

            self.accounts.token_metadata_program =
                AccountMeta::new_readonly(pubkey!("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"), false);

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self.accounts.rent =
                AccountMeta::new_readonly(pubkey!("SysvarRent111111111111111111111111111111111"), false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.creator.clone());

            metas.push(self.accounts.creator_ata.clone());

            metas.push(self.accounts.recipient.clone());

            metas.push(self.accounts.sender.clone());

            metas.push(self.accounts.nft_collection_data.clone());

            metas.push(self.accounts.nft_collection_master_edition.clone());

            metas.push(self.accounts.nft_collection_metadata.clone());

            metas.push(self.accounts.nft_collection_mint.clone());

            metas.push(self.accounts.deposit_token_mint.clone());

            metas.push(self.accounts.stream_nft_mint.clone());

            metas.push(self.accounts.recipient_stream_nft_ata.clone());

            metas.push(self.accounts.stream_data.clone());

            metas.push(self.accounts.stream_data_ata.clone());

            metas.push(self.accounts.stream_nft_master_edition.clone());

            metas.push(self.accounts.stream_nft_metadata.clone());

            metas.push(self.accounts.associated_token_program.clone());

            metas.push(self.accounts.deposit_token_program.clone());

            metas.push(self.accounts.nft_token_program.clone());

            metas.push(self.accounts.token_metadata_program.clone());

            metas.push(self.accounts.system_program.clone());

            metas.push(self.accounts.rent.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: CreateWithTimestampsLl
    // ....................................................................

    /// Main instruction struct for CreateWithTimestampsLl
    pub struct CreateWithTimestampsLlInstruction {
        pub accounts: CreateWithTimestampsLlInstructionAccountMetas,
        pub data: CreateWithTimestampsLlInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for CreateWithTimestampsLl instruction
    #[derive(Debug, Clone, Default)]
    pub struct CreateWithTimestampsLlInstructionAccountMetas {
        pub creator: AccountMeta,

        pub creator_ata: AccountMeta,

        pub recipient: AccountMeta,

        pub sender: AccountMeta,

        pub nft_collection_data: AccountMeta,

        pub nft_collection_master_edition: AccountMeta,

        pub nft_collection_metadata: AccountMeta,

        pub nft_collection_mint: AccountMeta,

        pub deposit_token_mint: AccountMeta,

        pub stream_nft_mint: AccountMeta,

        pub recipient_stream_nft_ata: AccountMeta,

        pub stream_data: AccountMeta,

        pub stream_data_ata: AccountMeta,

        pub stream_nft_master_edition: AccountMeta,

        pub stream_nft_metadata: AccountMeta,

        pub associated_token_program: AccountMeta,

        pub deposit_token_program: AccountMeta,

        pub nft_token_program: AccountMeta,

        pub token_metadata_program: AccountMeta,

        pub system_program: AccountMeta,

        pub rent: AccountMeta,
    }

    /// Account pubkeys for CreateWithTimestampsLl instruction
    #[derive(Debug, Clone)]
    pub struct CreateWithTimestampsLlInstructionAccounts {
        pub creator: Pubkey,

        pub creator_ata: Pubkey,

        pub recipient: Pubkey,

        pub sender: Pubkey,

        pub nft_collection_data: Pubkey,

        pub nft_collection_master_edition: Pubkey,

        pub nft_collection_metadata: Pubkey,

        pub nft_collection_mint: Pubkey,

        pub deposit_token_mint: Pubkey,

        pub stream_nft_mint: Pubkey,

        pub recipient_stream_nft_ata: Pubkey,

        pub stream_data: Pubkey,

        pub stream_data_ata: Pubkey,

        pub stream_nft_master_edition: Pubkey,

        pub stream_nft_metadata: Pubkey,

        pub deposit_token_program: Pubkey,

        pub nft_token_program: Pubkey,
    }

    impl CreateWithTimestampsLlInstructionAccounts {
        pub fn new(
            creator: Pubkey,

            creator_ata: Pubkey,

            recipient: Pubkey,

            sender: Pubkey,

            nft_collection_data: Pubkey,

            nft_collection_master_edition: Pubkey,

            nft_collection_metadata: Pubkey,

            nft_collection_mint: Pubkey,

            deposit_token_mint: Pubkey,

            stream_nft_mint: Pubkey,

            recipient_stream_nft_ata: Pubkey,

            stream_data: Pubkey,

            stream_data_ata: Pubkey,

            stream_nft_master_edition: Pubkey,

            stream_nft_metadata: Pubkey,

            deposit_token_program: Pubkey,

            nft_token_program: Pubkey,
        ) -> Self {
            Self {
                creator,

                creator_ata,

                recipient,

                sender,

                nft_collection_data,

                nft_collection_master_edition,

                nft_collection_metadata,

                nft_collection_mint,

                deposit_token_mint,

                stream_nft_mint,

                recipient_stream_nft_ata,

                stream_data,

                stream_data_ata,

                stream_nft_master_edition,

                stream_nft_metadata,

                deposit_token_program,

                nft_token_program,
            }
        }
    }

    /// Instruction data for CreateWithTimestampsLl
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct CreateWithTimestampsLlInstructionData {
        pub salt: u128,

        pub deposit_amount: u64,

        pub start_time: u64,

        pub cliff_time: u64,

        pub end_time: u64,

        pub start_unlock_amount: u64,

        pub cliff_unlock_amount: u64,

        pub is_cancelable: bool,
    }

    impl CreateWithTimestampsLlInstructionData {
        pub fn new(
            salt: u128,

            deposit_amount: u64,

            start_time: u64,

            cliff_time: u64,

            end_time: u64,

            start_unlock_amount: u64,

            cliff_unlock_amount: u64,

            is_cancelable: bool,
        ) -> Self {
            Self {
                salt,

                deposit_amount,

                start_time,

                cliff_time,

                end_time,

                start_unlock_amount,

                cliff_unlock_amount,

                is_cancelable,
            }
        }
    }

    /// Implementation for CreateWithTimestampsLlInstruction
    impl CreateWithTimestampsLlInstruction {
        fn discriminator() -> [u8; 8] {
            [150u8, 165u8, 147u8, 28u8, 68u8, 41u8, 48u8, 41u8]
        }

        pub fn data(data: CreateWithTimestampsLlInstructionData) -> Self {
            Self {
                accounts: CreateWithTimestampsLlInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: CreateWithTimestampsLlInstructionAccounts) -> Self {
            self.accounts.creator = AccountMeta::new(accounts.creator, true);

            self.accounts.creator_ata = AccountMeta::new(accounts.creator_ata, false);

            self.accounts.recipient = AccountMeta::new_readonly(accounts.recipient, false);

            self.accounts.sender = AccountMeta::new_readonly(accounts.sender, false);

            self.accounts.nft_collection_data = AccountMeta::new(accounts.nft_collection_data, false);

            self.accounts.nft_collection_master_edition =
                AccountMeta::new_readonly(accounts.nft_collection_master_edition, false);

            self.accounts.nft_collection_metadata = AccountMeta::new(accounts.nft_collection_metadata, false);

            self.accounts.nft_collection_mint = AccountMeta::new_readonly(accounts.nft_collection_mint, false);

            self.accounts.deposit_token_mint = AccountMeta::new_readonly(accounts.deposit_token_mint, false);

            self.accounts.stream_nft_mint = AccountMeta::new(accounts.stream_nft_mint, false);

            self.accounts.recipient_stream_nft_ata = AccountMeta::new(accounts.recipient_stream_nft_ata, false);

            self.accounts.stream_data = AccountMeta::new(accounts.stream_data, false);

            self.accounts.stream_data_ata = AccountMeta::new(accounts.stream_data_ata, false);

            self.accounts.stream_nft_master_edition = AccountMeta::new(accounts.stream_nft_master_edition, false);

            self.accounts.stream_nft_metadata = AccountMeta::new(accounts.stream_nft_metadata, false);

            self.accounts.associated_token_program =
                AccountMeta::new_readonly(pubkey!("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"), false);

            self.accounts.deposit_token_program = AccountMeta::new_readonly(accounts.deposit_token_program, false);

            self.accounts.nft_token_program = AccountMeta::new_readonly(accounts.nft_token_program, false);

            self.accounts.token_metadata_program =
                AccountMeta::new_readonly(pubkey!("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"), false);

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self.accounts.rent =
                AccountMeta::new_readonly(pubkey!("SysvarRent111111111111111111111111111111111"), false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.creator.clone());

            metas.push(self.accounts.creator_ata.clone());

            metas.push(self.accounts.recipient.clone());

            metas.push(self.accounts.sender.clone());

            metas.push(self.accounts.nft_collection_data.clone());

            metas.push(self.accounts.nft_collection_master_edition.clone());

            metas.push(self.accounts.nft_collection_metadata.clone());

            metas.push(self.accounts.nft_collection_mint.clone());

            metas.push(self.accounts.deposit_token_mint.clone());

            metas.push(self.accounts.stream_nft_mint.clone());

            metas.push(self.accounts.recipient_stream_nft_ata.clone());

            metas.push(self.accounts.stream_data.clone());

            metas.push(self.accounts.stream_data_ata.clone());

            metas.push(self.accounts.stream_nft_master_edition.clone());

            metas.push(self.accounts.stream_nft_metadata.clone());

            metas.push(self.accounts.associated_token_program.clone());

            metas.push(self.accounts.deposit_token_program.clone());

            metas.push(self.accounts.nft_token_program.clone());

            metas.push(self.accounts.token_metadata_program.clone());

            metas.push(self.accounts.system_program.clone());

            metas.push(self.accounts.rent.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: Initialize
    // ....................................................................

    /// Main instruction struct for Initialize
    pub struct InitializeInstruction {
        pub accounts: InitializeInstructionAccountMetas,
        pub data: InitializeInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for Initialize instruction
    #[derive(Debug, Clone, Default)]
    pub struct InitializeInstructionAccountMetas {
        pub initializer: AccountMeta,

        pub treasury: AccountMeta,

        pub nft_collection_data: AccountMeta,

        pub nft_collection_master_edition: AccountMeta,

        pub nft_collection_metadata: AccountMeta,

        pub nft_collection_mint: AccountMeta,

        pub nft_collection_ata: AccountMeta,

        pub associated_token_program: AccountMeta,

        pub nft_token_program: AccountMeta,

        pub token_metadata_program: AccountMeta,

        pub rent: AccountMeta,

        pub system_program: AccountMeta,
    }

    /// Account pubkeys for Initialize instruction
    #[derive(Debug, Clone)]
    pub struct InitializeInstructionAccounts {
        pub initializer: Pubkey,

        pub treasury: Pubkey,

        pub nft_collection_data: Pubkey,

        pub nft_collection_master_edition: Pubkey,

        pub nft_collection_metadata: Pubkey,

        pub nft_collection_mint: Pubkey,

        pub nft_collection_ata: Pubkey,

        pub nft_token_program: Pubkey,
    }

    impl InitializeInstructionAccounts {
        pub fn new(
            initializer: Pubkey,

            treasury: Pubkey,

            nft_collection_data: Pubkey,

            nft_collection_master_edition: Pubkey,

            nft_collection_metadata: Pubkey,

            nft_collection_mint: Pubkey,

            nft_collection_ata: Pubkey,

            nft_token_program: Pubkey,
        ) -> Self {
            Self {
                initializer,

                treasury,

                nft_collection_data,

                nft_collection_master_edition,

                nft_collection_metadata,

                nft_collection_mint,

                nft_collection_ata,

                nft_token_program,
            }
        }
    }

    /// Instruction data for Initialize
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct InitializeInstructionData {
        pub fee_collector: Pubkey,

        pub chainlink_program: Pubkey,

        pub chainlink_sol_usd_feed: Pubkey,
    }

    impl InitializeInstructionData {
        pub fn new(fee_collector: Pubkey, chainlink_program: Pubkey, chainlink_sol_usd_feed: Pubkey) -> Self {
            Self {
                fee_collector,

                chainlink_program,

                chainlink_sol_usd_feed,
            }
        }
    }

    /// Implementation for InitializeInstruction
    impl InitializeInstruction {
        fn discriminator() -> [u8; 8] {
            [175u8, 175u8, 109u8, 31u8, 13u8, 152u8, 155u8, 237u8]
        }

        pub fn data(data: InitializeInstructionData) -> Self {
            Self {
                accounts: InitializeInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: InitializeInstructionAccounts) -> Self {
            self.accounts.initializer = AccountMeta::new(accounts.initializer, true);

            self.accounts.treasury = AccountMeta::new(accounts.treasury, false);

            self.accounts.nft_collection_data = AccountMeta::new(accounts.nft_collection_data, false);

            self.accounts.nft_collection_master_edition =
                AccountMeta::new(accounts.nft_collection_master_edition, false);

            self.accounts.nft_collection_metadata = AccountMeta::new(accounts.nft_collection_metadata, false);

            self.accounts.nft_collection_mint = AccountMeta::new(accounts.nft_collection_mint, false);

            self.accounts.nft_collection_ata = AccountMeta::new(accounts.nft_collection_ata, false);

            self.accounts.associated_token_program =
                AccountMeta::new_readonly(pubkey!("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"), false);

            self.accounts.nft_token_program = AccountMeta::new_readonly(accounts.nft_token_program, false);

            self.accounts.token_metadata_program =
                AccountMeta::new_readonly(pubkey!("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"), false);

            self.accounts.rent =
                AccountMeta::new_readonly(pubkey!("SysvarRent111111111111111111111111111111111"), false);

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.initializer.clone());

            metas.push(self.accounts.treasury.clone());

            metas.push(self.accounts.nft_collection_data.clone());

            metas.push(self.accounts.nft_collection_master_edition.clone());

            metas.push(self.accounts.nft_collection_metadata.clone());

            metas.push(self.accounts.nft_collection_mint.clone());

            metas.push(self.accounts.nft_collection_ata.clone());

            metas.push(self.accounts.associated_token_program.clone());

            metas.push(self.accounts.nft_token_program.clone());

            metas.push(self.accounts.token_metadata_program.clone());

            metas.push(self.accounts.rent.clone());

            metas.push(self.accounts.system_program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: RefundableAmountOf
    // ....................................................................

    /// Main instruction struct for RefundableAmountOf
    pub struct RefundableAmountOfInstruction {
        pub accounts: RefundableAmountOfInstructionAccountMetas,
        pub data: RefundableAmountOfInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for RefundableAmountOf instruction
    #[derive(Debug, Clone, Default)]
    pub struct RefundableAmountOfInstructionAccountMetas {
        pub stream_data: AccountMeta,

        pub stream_nft_mint: AccountMeta,
    }

    /// Account pubkeys for RefundableAmountOf instruction
    #[derive(Debug, Clone)]
    pub struct RefundableAmountOfInstructionAccounts {
        pub stream_data: Pubkey,

        pub stream_nft_mint: Pubkey,
    }

    impl RefundableAmountOfInstructionAccounts {
        pub fn new(stream_data: Pubkey, stream_nft_mint: Pubkey) -> Self {
            Self {
                stream_data,

                stream_nft_mint,
            }
        }
    }

    /// Instruction data for RefundableAmountOf
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct RefundableAmountOfInstructionData {}

    impl RefundableAmountOfInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for RefundableAmountOfInstruction
    impl RefundableAmountOfInstruction {
        fn discriminator() -> [u8; 8] {
            [160u8, 136u8, 114u8, 120u8, 234u8, 178u8, 146u8, 58u8]
        }

        pub fn data(data: RefundableAmountOfInstructionData) -> Self {
            Self {
                accounts: RefundableAmountOfInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: RefundableAmountOfInstructionAccounts) -> Self {
            self.accounts.stream_data = AccountMeta::new_readonly(accounts.stream_data, false);

            self.accounts.stream_nft_mint = AccountMeta::new_readonly(accounts.stream_nft_mint, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.stream_data.clone());

            metas.push(self.accounts.stream_nft_mint.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: Renounce
    // ....................................................................

    /// Main instruction struct for Renounce
    pub struct RenounceInstruction {
        pub accounts: RenounceInstructionAccountMetas,
        pub data: RenounceInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for Renounce instruction
    #[derive(Debug, Clone, Default)]
    pub struct RenounceInstructionAccountMetas {
        pub sender: AccountMeta,

        pub stream_data: AccountMeta,

        pub stream_nft_mint: AccountMeta,
    }

    /// Account pubkeys for Renounce instruction
    #[derive(Debug, Clone)]
    pub struct RenounceInstructionAccounts {
        pub sender: Pubkey,

        pub stream_data: Pubkey,

        pub stream_nft_mint: Pubkey,
    }

    impl RenounceInstructionAccounts {
        pub fn new(sender: Pubkey, stream_data: Pubkey, stream_nft_mint: Pubkey) -> Self {
            Self {
                sender,

                stream_data,

                stream_nft_mint,
            }
        }
    }

    /// Instruction data for Renounce
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct RenounceInstructionData {}

    impl RenounceInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for RenounceInstruction
    impl RenounceInstruction {
        fn discriminator() -> [u8; 8] {
            [241u8, 157u8, 138u8, 210u8, 8u8, 235u8, 187u8, 123u8]
        }

        pub fn data(data: RenounceInstructionData) -> Self {
            Self {
                accounts: RenounceInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: RenounceInstructionAccounts) -> Self {
            self.accounts.sender = AccountMeta::new_readonly(accounts.sender, true);

            self.accounts.stream_data = AccountMeta::new(accounts.stream_data, false);

            self.accounts.stream_nft_mint = AccountMeta::new_readonly(accounts.stream_nft_mint, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.sender.clone());

            metas.push(self.accounts.stream_data.clone());

            metas.push(self.accounts.stream_nft_mint.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: StatusOf
    // ....................................................................

    /// Main instruction struct for StatusOf
    pub struct StatusOfInstruction {
        pub accounts: StatusOfInstructionAccountMetas,
        pub data: StatusOfInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for StatusOf instruction
    #[derive(Debug, Clone, Default)]
    pub struct StatusOfInstructionAccountMetas {
        pub stream_data: AccountMeta,

        pub stream_nft_mint: AccountMeta,
    }

    /// Account pubkeys for StatusOf instruction
    #[derive(Debug, Clone)]
    pub struct StatusOfInstructionAccounts {
        pub stream_data: Pubkey,

        pub stream_nft_mint: Pubkey,
    }

    impl StatusOfInstructionAccounts {
        pub fn new(stream_data: Pubkey, stream_nft_mint: Pubkey) -> Self {
            Self {
                stream_data,

                stream_nft_mint,
            }
        }
    }

    /// Instruction data for StatusOf
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct StatusOfInstructionData {}

    impl StatusOfInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for StatusOfInstruction
    impl StatusOfInstruction {
        fn discriminator() -> [u8; 8] {
            [90u8, 214u8, 253u8, 237u8, 126u8, 236u8, 132u8, 237u8]
        }

        pub fn data(data: StatusOfInstructionData) -> Self {
            Self {
                accounts: StatusOfInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: StatusOfInstructionAccounts) -> Self {
            self.accounts.stream_data = AccountMeta::new_readonly(accounts.stream_data, false);

            self.accounts.stream_nft_mint = AccountMeta::new_readonly(accounts.stream_nft_mint, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.stream_data.clone());

            metas.push(self.accounts.stream_nft_mint.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: StreamExists
    // ....................................................................

    /// Main instruction struct for StreamExists
    pub struct StreamExistsInstruction {
        pub accounts: StreamExistsInstructionAccountMetas,
        pub data: StreamExistsInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for StreamExists instruction
    #[derive(Debug, Clone, Default)]
    pub struct StreamExistsInstructionAccountMetas {
        pub stream_nft_mint: AccountMeta,
    }

    /// Account pubkeys for StreamExists instruction
    #[derive(Debug, Clone)]
    pub struct StreamExistsInstructionAccounts {
        pub stream_nft_mint: Pubkey,
    }

    impl StreamExistsInstructionAccounts {
        pub fn new(stream_nft_mint: Pubkey) -> Self {
            Self {
                stream_nft_mint,
            }
        }
    }

    /// Instruction data for StreamExists
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct StreamExistsInstructionData {
        pub _sender: Pubkey,

        pub _salt: u128,
    }

    impl StreamExistsInstructionData {
        pub fn new(_sender: Pubkey, _salt: u128) -> Self {
            Self {
                _sender,

                _salt,
            }
        }
    }

    /// Implementation for StreamExistsInstruction
    impl StreamExistsInstruction {
        fn discriminator() -> [u8; 8] {
            [104u8, 209u8, 104u8, 97u8, 122u8, 35u8, 165u8, 195u8]
        }

        pub fn data(data: StreamExistsInstructionData) -> Self {
            Self {
                accounts: StreamExistsInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: StreamExistsInstructionAccounts) -> Self {
            self.accounts.stream_nft_mint = AccountMeta::new_readonly(accounts.stream_nft_mint, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.stream_nft_mint.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: StreamedAmountOf
    // ....................................................................

    /// Main instruction struct for StreamedAmountOf
    pub struct StreamedAmountOfInstruction {
        pub accounts: StreamedAmountOfInstructionAccountMetas,
        pub data: StreamedAmountOfInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for StreamedAmountOf instruction
    #[derive(Debug, Clone, Default)]
    pub struct StreamedAmountOfInstructionAccountMetas {
        pub stream_data: AccountMeta,

        pub stream_nft_mint: AccountMeta,
    }

    /// Account pubkeys for StreamedAmountOf instruction
    #[derive(Debug, Clone)]
    pub struct StreamedAmountOfInstructionAccounts {
        pub stream_data: Pubkey,

        pub stream_nft_mint: Pubkey,
    }

    impl StreamedAmountOfInstructionAccounts {
        pub fn new(stream_data: Pubkey, stream_nft_mint: Pubkey) -> Self {
            Self {
                stream_data,

                stream_nft_mint,
            }
        }
    }

    /// Instruction data for StreamedAmountOf
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct StreamedAmountOfInstructionData {}

    impl StreamedAmountOfInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for StreamedAmountOfInstruction
    impl StreamedAmountOfInstruction {
        fn discriminator() -> [u8; 8] {
            [91u8, 69u8, 219u8, 48u8, 189u8, 26u8, 13u8, 33u8]
        }

        pub fn data(data: StreamedAmountOfInstructionData) -> Self {
            Self {
                accounts: StreamedAmountOfInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: StreamedAmountOfInstructionAccounts) -> Self {
            self.accounts.stream_data = AccountMeta::new_readonly(accounts.stream_data, false);

            self.accounts.stream_nft_mint = AccountMeta::new_readonly(accounts.stream_nft_mint, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.stream_data.clone());

            metas.push(self.accounts.stream_nft_mint.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: TreasuryView
    // ....................................................................

    /// Main instruction struct for TreasuryView
    pub struct TreasuryViewInstruction {
        pub accounts: TreasuryViewInstructionAccountMetas,
        pub data: TreasuryViewInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for TreasuryView instruction
    #[derive(Debug, Clone, Default)]
    pub struct TreasuryViewInstructionAccountMetas {
        pub treasury: AccountMeta,
    }

    /// Account pubkeys for TreasuryView instruction
    #[derive(Debug, Clone)]
    pub struct TreasuryViewInstructionAccounts {
        pub treasury: Pubkey,
    }

    impl TreasuryViewInstructionAccounts {
        pub fn new(treasury: Pubkey) -> Self {
            Self {
                treasury,
            }
        }
    }

    /// Instruction data for TreasuryView
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct TreasuryViewInstructionData {}

    impl TreasuryViewInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for TreasuryViewInstruction
    impl TreasuryViewInstruction {
        fn discriminator() -> [u8; 8] {
            [247u8, 160u8, 213u8, 237u8, 247u8, 121u8, 164u8, 82u8]
        }

        pub fn data(data: TreasuryViewInstructionData) -> Self {
            Self {
                accounts: TreasuryViewInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: TreasuryViewInstructionAccounts) -> Self {
            self.accounts.treasury = AccountMeta::new_readonly(accounts.treasury, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.treasury.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: Withdraw
    // ....................................................................

    /// Main instruction struct for Withdraw
    pub struct WithdrawInstruction {
        pub accounts: WithdrawInstructionAccountMetas,
        pub data: WithdrawInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for Withdraw instruction
    #[derive(Debug, Clone, Default)]
    pub struct WithdrawInstructionAccountMetas {
        pub signer: AccountMeta,

        pub stream_recipient: AccountMeta,

        pub withdrawal_recipient: AccountMeta,

        pub withdrawal_recipient_ata: AccountMeta,

        pub treasury: AccountMeta,

        pub deposited_token_mint: AccountMeta,

        pub recipient_stream_nft_ata: AccountMeta,

        pub stream_data: AccountMeta,

        pub stream_data_ata: AccountMeta,

        pub stream_nft_mint: AccountMeta,

        pub associated_token_program: AccountMeta,

        pub chainlink_program: AccountMeta,

        pub chainlink_sol_usd_feed: AccountMeta,

        pub deposited_token_program: AccountMeta,

        pub nft_token_program: AccountMeta,

        pub system_program: AccountMeta,
    }

    /// Account pubkeys for Withdraw instruction
    #[derive(Debug, Clone)]
    pub struct WithdrawInstructionAccounts {
        pub signer: Pubkey,

        pub stream_recipient: Pubkey,

        pub withdrawal_recipient: Pubkey,

        pub withdrawal_recipient_ata: Pubkey,

        pub treasury: Pubkey,

        pub deposited_token_mint: Pubkey,

        pub recipient_stream_nft_ata: Pubkey,

        pub stream_data: Pubkey,

        pub stream_data_ata: Pubkey,

        pub stream_nft_mint: Pubkey,

        pub chainlink_program: Pubkey,

        pub chainlink_sol_usd_feed: Pubkey,

        pub deposited_token_program: Pubkey,

        pub nft_token_program: Pubkey,
    }

    impl WithdrawInstructionAccounts {
        pub fn new(
            signer: Pubkey,

            stream_recipient: Pubkey,

            withdrawal_recipient: Pubkey,

            withdrawal_recipient_ata: Pubkey,

            treasury: Pubkey,

            deposited_token_mint: Pubkey,

            recipient_stream_nft_ata: Pubkey,

            stream_data: Pubkey,

            stream_data_ata: Pubkey,

            stream_nft_mint: Pubkey,

            chainlink_program: Pubkey,

            chainlink_sol_usd_feed: Pubkey,

            deposited_token_program: Pubkey,

            nft_token_program: Pubkey,
        ) -> Self {
            Self {
                signer,

                stream_recipient,

                withdrawal_recipient,

                withdrawal_recipient_ata,

                treasury,

                deposited_token_mint,

                recipient_stream_nft_ata,

                stream_data,

                stream_data_ata,

                stream_nft_mint,

                chainlink_program,

                chainlink_sol_usd_feed,

                deposited_token_program,

                nft_token_program,
            }
        }
    }

    /// Instruction data for Withdraw
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct WithdrawInstructionData {
        pub amount: u64,
    }

    impl WithdrawInstructionData {
        pub fn new(amount: u64) -> Self {
            Self {
                amount,
            }
        }
    }

    /// Implementation for WithdrawInstruction
    impl WithdrawInstruction {
        fn discriminator() -> [u8; 8] {
            [183u8, 18u8, 70u8, 156u8, 148u8, 109u8, 161u8, 34u8]
        }

        pub fn data(data: WithdrawInstructionData) -> Self {
            Self {
                accounts: WithdrawInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: WithdrawInstructionAccounts) -> Self {
            self.accounts.signer = AccountMeta::new(accounts.signer, true);

            self.accounts.stream_recipient = AccountMeta::new_readonly(accounts.stream_recipient, false);

            self.accounts.withdrawal_recipient = AccountMeta::new_readonly(accounts.withdrawal_recipient, false);

            self.accounts.withdrawal_recipient_ata = AccountMeta::new(accounts.withdrawal_recipient_ata, false);

            self.accounts.treasury = AccountMeta::new(accounts.treasury, false);

            self.accounts.deposited_token_mint = AccountMeta::new_readonly(accounts.deposited_token_mint, false);

            self.accounts.recipient_stream_nft_ata =
                AccountMeta::new_readonly(accounts.recipient_stream_nft_ata, false);

            self.accounts.stream_data = AccountMeta::new(accounts.stream_data, false);

            self.accounts.stream_data_ata = AccountMeta::new(accounts.stream_data_ata, false);

            self.accounts.stream_nft_mint = AccountMeta::new_readonly(accounts.stream_nft_mint, false);

            self.accounts.associated_token_program =
                AccountMeta::new_readonly(pubkey!("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"), false);

            self.accounts.chainlink_program = AccountMeta::new_readonly(accounts.chainlink_program, false);

            self.accounts.chainlink_sol_usd_feed = AccountMeta::new_readonly(accounts.chainlink_sol_usd_feed, false);

            self.accounts.deposited_token_program = AccountMeta::new_readonly(accounts.deposited_token_program, false);

            self.accounts.nft_token_program = AccountMeta::new_readonly(accounts.nft_token_program, false);

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.signer.clone());

            metas.push(self.accounts.stream_recipient.clone());

            metas.push(self.accounts.withdrawal_recipient.clone());

            metas.push(self.accounts.withdrawal_recipient_ata.clone());

            metas.push(self.accounts.treasury.clone());

            metas.push(self.accounts.deposited_token_mint.clone());

            metas.push(self.accounts.recipient_stream_nft_ata.clone());

            metas.push(self.accounts.stream_data.clone());

            metas.push(self.accounts.stream_data_ata.clone());

            metas.push(self.accounts.stream_nft_mint.clone());

            metas.push(self.accounts.associated_token_program.clone());

            metas.push(self.accounts.chainlink_program.clone());

            metas.push(self.accounts.chainlink_sol_usd_feed.clone());

            metas.push(self.accounts.deposited_token_program.clone());

            metas.push(self.accounts.nft_token_program.clone());

            metas.push(self.accounts.system_program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: WithdrawMax
    // ....................................................................

    /// Main instruction struct for WithdrawMax
    pub struct WithdrawMaxInstruction {
        pub accounts: WithdrawMaxInstructionAccountMetas,
        pub data: WithdrawMaxInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for WithdrawMax instruction
    #[derive(Debug, Clone, Default)]
    pub struct WithdrawMaxInstructionAccountMetas {
        pub signer: AccountMeta,

        pub stream_recipient: AccountMeta,

        pub withdrawal_recipient: AccountMeta,

        pub withdrawal_recipient_ata: AccountMeta,

        pub treasury: AccountMeta,

        pub deposited_token_mint: AccountMeta,

        pub recipient_stream_nft_ata: AccountMeta,

        pub stream_data: AccountMeta,

        pub stream_data_ata: AccountMeta,

        pub stream_nft_mint: AccountMeta,

        pub associated_token_program: AccountMeta,

        pub chainlink_program: AccountMeta,

        pub chainlink_sol_usd_feed: AccountMeta,

        pub deposited_token_program: AccountMeta,

        pub nft_token_program: AccountMeta,

        pub system_program: AccountMeta,
    }

    /// Account pubkeys for WithdrawMax instruction
    #[derive(Debug, Clone)]
    pub struct WithdrawMaxInstructionAccounts {
        pub signer: Pubkey,

        pub stream_recipient: Pubkey,

        pub withdrawal_recipient: Pubkey,

        pub withdrawal_recipient_ata: Pubkey,

        pub treasury: Pubkey,

        pub deposited_token_mint: Pubkey,

        pub recipient_stream_nft_ata: Pubkey,

        pub stream_data: Pubkey,

        pub stream_data_ata: Pubkey,

        pub stream_nft_mint: Pubkey,

        pub chainlink_program: Pubkey,

        pub chainlink_sol_usd_feed: Pubkey,

        pub deposited_token_program: Pubkey,

        pub nft_token_program: Pubkey,
    }

    impl WithdrawMaxInstructionAccounts {
        pub fn new(
            signer: Pubkey,

            stream_recipient: Pubkey,

            withdrawal_recipient: Pubkey,

            withdrawal_recipient_ata: Pubkey,

            treasury: Pubkey,

            deposited_token_mint: Pubkey,

            recipient_stream_nft_ata: Pubkey,

            stream_data: Pubkey,

            stream_data_ata: Pubkey,

            stream_nft_mint: Pubkey,

            chainlink_program: Pubkey,

            chainlink_sol_usd_feed: Pubkey,

            deposited_token_program: Pubkey,

            nft_token_program: Pubkey,
        ) -> Self {
            Self {
                signer,

                stream_recipient,

                withdrawal_recipient,

                withdrawal_recipient_ata,

                treasury,

                deposited_token_mint,

                recipient_stream_nft_ata,

                stream_data,

                stream_data_ata,

                stream_nft_mint,

                chainlink_program,

                chainlink_sol_usd_feed,

                deposited_token_program,

                nft_token_program,
            }
        }
    }

    /// Instruction data for WithdrawMax
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct WithdrawMaxInstructionData {}

    impl WithdrawMaxInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for WithdrawMaxInstruction
    impl WithdrawMaxInstruction {
        fn discriminator() -> [u8; 8] {
            [32u8, 71u8, 46u8, 98u8, 105u8, 76u8, 85u8, 96u8]
        }

        pub fn data(data: WithdrawMaxInstructionData) -> Self {
            Self {
                accounts: WithdrawMaxInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: WithdrawMaxInstructionAccounts) -> Self {
            self.accounts.signer = AccountMeta::new(accounts.signer, true);

            self.accounts.stream_recipient = AccountMeta::new_readonly(accounts.stream_recipient, false);

            self.accounts.withdrawal_recipient = AccountMeta::new_readonly(accounts.withdrawal_recipient, false);

            self.accounts.withdrawal_recipient_ata = AccountMeta::new(accounts.withdrawal_recipient_ata, false);

            self.accounts.treasury = AccountMeta::new(accounts.treasury, false);

            self.accounts.deposited_token_mint = AccountMeta::new_readonly(accounts.deposited_token_mint, false);

            self.accounts.recipient_stream_nft_ata =
                AccountMeta::new_readonly(accounts.recipient_stream_nft_ata, false);

            self.accounts.stream_data = AccountMeta::new(accounts.stream_data, false);

            self.accounts.stream_data_ata = AccountMeta::new(accounts.stream_data_ata, false);

            self.accounts.stream_nft_mint = AccountMeta::new_readonly(accounts.stream_nft_mint, false);

            self.accounts.associated_token_program =
                AccountMeta::new_readonly(pubkey!("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"), false);

            self.accounts.chainlink_program = AccountMeta::new_readonly(accounts.chainlink_program, false);

            self.accounts.chainlink_sol_usd_feed = AccountMeta::new_readonly(accounts.chainlink_sol_usd_feed, false);

            self.accounts.deposited_token_program = AccountMeta::new_readonly(accounts.deposited_token_program, false);

            self.accounts.nft_token_program = AccountMeta::new_readonly(accounts.nft_token_program, false);

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.signer.clone());

            metas.push(self.accounts.stream_recipient.clone());

            metas.push(self.accounts.withdrawal_recipient.clone());

            metas.push(self.accounts.withdrawal_recipient_ata.clone());

            metas.push(self.accounts.treasury.clone());

            metas.push(self.accounts.deposited_token_mint.clone());

            metas.push(self.accounts.recipient_stream_nft_ata.clone());

            metas.push(self.accounts.stream_data.clone());

            metas.push(self.accounts.stream_data_ata.clone());

            metas.push(self.accounts.stream_nft_mint.clone());

            metas.push(self.accounts.associated_token_program.clone());

            metas.push(self.accounts.chainlink_program.clone());

            metas.push(self.accounts.chainlink_sol_usd_feed.clone());

            metas.push(self.accounts.deposited_token_program.clone());

            metas.push(self.accounts.nft_token_program.clone());

            metas.push(self.accounts.system_program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: WithdrawableAmountOf
    // ....................................................................

    /// Main instruction struct for WithdrawableAmountOf
    pub struct WithdrawableAmountOfInstruction {
        pub accounts: WithdrawableAmountOfInstructionAccountMetas,
        pub data: WithdrawableAmountOfInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for WithdrawableAmountOf instruction
    #[derive(Debug, Clone, Default)]
    pub struct WithdrawableAmountOfInstructionAccountMetas {
        pub stream_data: AccountMeta,

        pub stream_nft_mint: AccountMeta,
    }

    /// Account pubkeys for WithdrawableAmountOf instruction
    #[derive(Debug, Clone)]
    pub struct WithdrawableAmountOfInstructionAccounts {
        pub stream_data: Pubkey,

        pub stream_nft_mint: Pubkey,
    }

    impl WithdrawableAmountOfInstructionAccounts {
        pub fn new(stream_data: Pubkey, stream_nft_mint: Pubkey) -> Self {
            Self {
                stream_data,

                stream_nft_mint,
            }
        }
    }

    /// Instruction data for WithdrawableAmountOf
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct WithdrawableAmountOfInstructionData {}

    impl WithdrawableAmountOfInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for WithdrawableAmountOfInstruction
    impl WithdrawableAmountOfInstruction {
        fn discriminator() -> [u8; 8] {
            [30u8, 195u8, 140u8, 141u8, 173u8, 123u8, 253u8, 60u8]
        }

        pub fn data(data: WithdrawableAmountOfInstructionData) -> Self {
            Self {
                accounts: WithdrawableAmountOfInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: WithdrawableAmountOfInstructionAccounts) -> Self {
            self.accounts.stream_data = AccountMeta::new_readonly(accounts.stream_data, false);

            self.accounts.stream_nft_mint = AccountMeta::new_readonly(accounts.stream_nft_mint, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.stream_data.clone());

            metas.push(self.accounts.stream_nft_mint.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: WithdrawalFeeInLamports
    // ....................................................................

    /// Main instruction struct for WithdrawalFeeInLamports
    pub struct WithdrawalFeeInLamportsInstruction {
        pub accounts: WithdrawalFeeInLamportsInstructionAccountMetas,
        pub data: WithdrawalFeeInLamportsInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for WithdrawalFeeInLamports instruction
    #[derive(Debug, Clone, Default)]
    pub struct WithdrawalFeeInLamportsInstructionAccountMetas {
        pub treasury: AccountMeta,

        pub chainlink_program: AccountMeta,

        pub chainlink_sol_usd_feed: AccountMeta,
    }

    /// Account pubkeys for WithdrawalFeeInLamports instruction
    #[derive(Debug, Clone)]
    pub struct WithdrawalFeeInLamportsInstructionAccounts {
        pub treasury: Pubkey,

        pub chainlink_program: Pubkey,

        pub chainlink_sol_usd_feed: Pubkey,
    }

    impl WithdrawalFeeInLamportsInstructionAccounts {
        pub fn new(treasury: Pubkey, chainlink_program: Pubkey, chainlink_sol_usd_feed: Pubkey) -> Self {
            Self {
                treasury,

                chainlink_program,

                chainlink_sol_usd_feed,
            }
        }
    }

    /// Instruction data for WithdrawalFeeInLamports
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct WithdrawalFeeInLamportsInstructionData {}

    impl WithdrawalFeeInLamportsInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for WithdrawalFeeInLamportsInstruction
    impl WithdrawalFeeInLamportsInstruction {
        fn discriminator() -> [u8; 8] {
            [55u8, 255u8, 88u8, 224u8, 223u8, 23u8, 97u8, 140u8]
        }

        pub fn data(data: WithdrawalFeeInLamportsInstructionData) -> Self {
            Self {
                accounts: WithdrawalFeeInLamportsInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: WithdrawalFeeInLamportsInstructionAccounts) -> Self {
            self.accounts.treasury = AccountMeta::new_readonly(accounts.treasury, false);

            self.accounts.chainlink_program = AccountMeta::new_readonly(accounts.chainlink_program, false);

            self.accounts.chainlink_sol_usd_feed = AccountMeta::new_readonly(accounts.chainlink_sol_usd_feed, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.treasury.clone());

            metas.push(self.accounts.chainlink_program.clone());

            metas.push(self.accounts.chainlink_sol_usd_feed.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ------------------------------------------------------------------------
    // Composite Accounts
    // ------------------------------------------------------------------------
}

// ============================================================================
// CUSTOM TYPES
// ============================================================================

/// Custom struct: Amounts
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct Amounts {
    pub start_unlock: u64,

    pub cliff_unlock: u64,

    pub deposited: u64,

    pub refunded: u64,

    pub withdrawn: u64,
}

impl Amounts {
    pub fn new(start_unlock: u64, cliff_unlock: u64, deposited: u64, refunded: u64, withdrawn: u64) -> Self {
        Self {
            start_unlock,

            cliff_unlock,

            deposited,

            refunded,

            withdrawn,
        }
    }
}

/// Custom struct: CancelLockupStream
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct CancelLockupStream {
    pub deposited_token_mint: Pubkey,

    pub recipient_amount: u64,

    pub sender_amount: u64,

    pub stream_data: Pubkey,

    pub stream_nft_mint: Pubkey,
}

impl CancelLockupStream {
    pub fn new(
        deposited_token_mint: Pubkey,

        recipient_amount: u64,

        sender_amount: u64,

        stream_data: Pubkey,

        stream_nft_mint: Pubkey,
    ) -> Self {
        Self {
            deposited_token_mint,

            recipient_amount,

            sender_amount,

            stream_data,

            stream_nft_mint,
        }
    }
}

/// Custom struct: CreateLockupLinearStream
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct CreateLockupLinearStream {
    pub deposit_token_decimals: u8,

    pub deposit_token_mint: Pubkey,

    pub recipient: Pubkey,

    pub salt: u128,

    pub stream_data: Pubkey,

    pub stream_nft_mint: Pubkey,
}

impl CreateLockupLinearStream {
    pub fn new(
        deposit_token_decimals: u8,

        deposit_token_mint: Pubkey,

        recipient: Pubkey,

        salt: u128,

        stream_data: Pubkey,

        stream_nft_mint: Pubkey,
    ) -> Self {
        Self {
            deposit_token_decimals,

            deposit_token_mint,

            recipient,

            salt,

            stream_data,

            stream_nft_mint,
        }
    }
}

/// Custom struct: FeesCollected
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct FeesCollected {
    pub fee_amount: u64,

    pub fee_collector: Pubkey,

    pub fee_recipient: Pubkey,
}

impl FeesCollected {
    pub fn new(fee_amount: u64, fee_collector: Pubkey, fee_recipient: Pubkey) -> Self {
        Self {
            fee_amount,

            fee_collector,

            fee_recipient,
        }
    }
}

/// Custom struct: NftCollectionData
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct NftCollectionData {
    pub total_supply: u64,

    pub bump: u8,
}

impl NftCollectionData {
    pub fn new(total_supply: u64, bump: u8) -> Self {
        Self {
            total_supply,

            bump,
        }
    }
}

/// Custom struct: RenounceLockupStream
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct RenounceLockupStream {
    pub deposited_token_mint: Pubkey,

    pub stream_data: Pubkey,

    pub stream_nft_mint: Pubkey,
}

impl RenounceLockupStream {
    pub fn new(deposited_token_mint: Pubkey, stream_data: Pubkey, stream_nft_mint: Pubkey) -> Self {
        Self {
            deposited_token_mint,

            stream_data,

            stream_nft_mint,
        }
    }
}

/// Custom struct: StreamData
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct StreamData {
    pub amounts: Amounts,

    pub deposited_token_mint: Pubkey,

    pub bump: u8,

    pub salt: u128,

    pub is_cancelable: bool,

    pub is_depleted: bool,

    pub timestamps: Timestamps,

    pub sender: Pubkey,

    pub was_canceled: bool,
}

impl StreamData {
    pub fn new(
        amounts: Amounts,

        deposited_token_mint: Pubkey,

        bump: u8,

        salt: u128,

        is_cancelable: bool,

        is_depleted: bool,

        timestamps: Timestamps,

        sender: Pubkey,

        was_canceled: bool,
    ) -> Self {
        Self {
            amounts,

            deposited_token_mint,

            bump,

            salt,

            is_cancelable,

            is_depleted,

            timestamps,

            sender,

            was_canceled,
        }
    }
}

/// Custom enum: StreamStatus
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub enum StreamStatus {
    Pending,

    Streaming,

    Settled,

    Canceled,

    Depleted,
}

/// Custom struct: Timestamps
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct Timestamps {
    pub cliff: u64,

    pub end: u64,

    pub start: u64,
}

impl Timestamps {
    pub fn new(cliff: u64, end: u64, start: u64) -> Self {
        Self {
            cliff,

            end,

            start,
        }
    }
}

/// Custom struct: Treasury
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct Treasury {
    pub bump: u8,

    pub fee_collector: Pubkey,

    pub chainlink_program: Pubkey,

    pub chainlink_sol_usd_feed: Pubkey,
}

impl Treasury {
    pub fn new(bump: u8, fee_collector: Pubkey, chainlink_program: Pubkey, chainlink_sol_usd_feed: Pubkey) -> Self {
        Self {
            bump,

            fee_collector,

            chainlink_program,

            chainlink_sol_usd_feed,
        }
    }
}

/// Custom struct: WithdrawFromLockupStream
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct WithdrawFromLockupStream {
    pub deposited_token_mint: Pubkey,

    pub fee_in_lamports: u64,

    pub stream_data: Pubkey,

    pub stream_nft_mint: Pubkey,

    pub withdrawn_amount: u64,
}

impl WithdrawFromLockupStream {
    pub fn new(
        deposited_token_mint: Pubkey,

        fee_in_lamports: u64,

        stream_data: Pubkey,

        stream_nft_mint: Pubkey,

        withdrawn_amount: u64,
    ) -> Self {
        Self {
            deposited_token_mint,

            fee_in_lamports,

            stream_data,

            stream_nft_mint,

            withdrawn_amount,
        }
    }
}

// ============================================================================
// END OF GENERATED FILE
// ============================================================================
