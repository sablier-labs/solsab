/**
 * @file This script generates TypeScript bindings for the Solana program errors.
 */

import { readFileSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import _ from "lodash";
import { ProgramName as ProgramNameEnum } from "../../lib/enums";
import { type ProgramName } from "../../lib/types";

const ROOT_DIR = join(__dirname, "..", "..");
const IDL_DIR = join(ROOT_DIR, "target", "idl");
const TYPES_DIR = join(ROOT_DIR, "target", "types");

const VALID_PROGRAMS = ["all", ..._.values(ProgramNameEnum)];

function genErrors(programName: string) {
  const idlPath = join(IDL_DIR, `${programName}.json`);
  const { errors } = JSON.parse(readFileSync(idlPath, { encoding: "utf-8" }));
  if (!_.isArray(errors) || errors.some((e) => !e.name || !e.code)) {
    throw new Error("IDL incorrectly formatted");
  }

  const lines = [
    "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.",
    "export const ProgramErrorCode = {",
    ...errors.map(({ name, code }: { name: string; code: number }) => `  ${name}: ${code},`),
    "} as const;",
    "",
    "export type ProgramErrorName = keyof typeof ProgramErrorCode;",
  ].join("\n");

  const errorsPath = join(TYPES_DIR, `${programName}_errors.ts`);
  writeFileSync(errorsPath, lines);
}

function main() {
  const programName = process.argv[2] as ProgramName | "all";

  if (!programName || !VALID_PROGRAMS.includes(programName)) {
    console.error(`‚ùå Missing or Invalid program name: ${programName}`);
    console.error(`üìã Valid options: ${VALID_PROGRAMS.join(", ")}`);
    process.exit(1);
  }

  if (programName === "all") {
    genErrors(ProgramNameEnum.Lockup);
    genErrors(ProgramNameEnum.MerkleInstant);
    console.log("‚úîÔ∏è Successfully generated error bindings for all programs\n");
  } else {
    genErrors(programName);
    console.log(`‚úîÔ∏è Successfully generated error bindings for ${programName}\n`);
  }
}

if (require.main === module) {
  main();
}
