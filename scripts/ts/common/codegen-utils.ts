/**
 * @file Shared utilities for code generation scripts
 *
 * This module contains common functionality used by both codegen-errors.ts and codegen-structs.ts
 * to avoid duplication and ensure consistency across code generation scripts.
 */

import { readFileSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import _ from "lodash";
import { ProgramName as ProgramNameEnum } from "../../../lib/enums";
import { type ProgramName } from "../../../lib/types";

/* -------------------------------------------------------------------------- */
/*                                 CONSTANTS                                  */
/* -------------------------------------------------------------------------- */

/** Root directory of the project */
export const ROOT_DIR = join(__dirname, "..", "..", "..");

/** Directory containing Anchor-generated IDL JSON files */
export const IDL_DIR = join(ROOT_DIR, "target", "idl");

/** Directory for generated TypeScript files */
export const TYPES_DIR = join(ROOT_DIR, "target", "types");

/** Valid program names that can be processed by codegen scripts */
export const VALID_PROGRAMS = ["all", ..._.values(ProgramNameEnum)];

/* -------------------------------------------------------------------------- */
/*                                   TYPES                                    */
/* -------------------------------------------------------------------------- */

/**
 * Base structure of an Anchor IDL file
 */
export type BaseIdl = {
  address: string;
  metadata: {
    name: string;
    version: string;
    spec: string;
    description: string;
  };
  instructions: unknown[];
  accounts: unknown[];
  events: unknown[];
  errors?: IdlError[];
  types?: unknown[];
};

/**
 * Configuration for a code generation operation
 */
export type CodegenConfig = {
  /** Name of the program to generate code for */
  programName: string;
  /** Field to extract from the IDL (e.g., "errors", "types") */
  idlField: string;
  /** File suffix for the output file (e.g., "_errors", "_structs") */
  outputSuffix: string;
  /** Success message to display */
  successMessage: string;
};

/**
 * Error definition from an Anchor IDL
 */
export type IdlError = {
  code: number;
  name: string;
  msg?: string;
};

/**
 * Represents a field in an Anchor IDL type definition
 */
export type IdlField = {
  name: string;
  type: IdlTypeDefinition;
};

/**
 * Result of processing an IDL file
 */
export type IdlProcessResult<T = unknown> = {
  /** The extracted data from the IDL */
  data: T[];
  /** Generated TypeScript content */
  content: string;
};

/**
 * Represents the possible type definitions in an Anchor IDL
 *
 * Can be one of:
 * - string: Primitive type like "u64", "bool", "pubkey"
 * - { defined: { name: string } }: Reference to another type in the same IDL
 * - { array: [string, number] }: Array type with element type and size
 */
export type IdlTypeDefinition = string | { defined: { name: string } } | { array: [string, number] };

/**
 * Represents a complete type definition from the Anchor IDL
 */
export type IdlType = {
  name: string;
  type: {
    kind: "struct" | "enum";
    fields?: IdlField[];
    variants?: { name: string }[];
  };
};

/* -------------------------------------------------------------------------- */
/*                               CORE UTILITIES                              */
/* -------------------------------------------------------------------------- */

/**
 * Extracts a specific field from an IDL and validates it with type safety
 *
 * @template T - The expected type of the array elements
 * @param idl - The parsed IDL object
 * @param fieldName - The field to extract (e.g., "errors", "types")
 * @param validator - Optional validation function for the extracted data
 * @returns The extracted and validated data with proper typing
 * @throws Error if the field is missing, not an array, or validation fails
 */
export function extractIdlField<T = unknown>(
  idl: BaseIdl,
  fieldName: keyof BaseIdl,
  validator?: (data: T[]) => boolean,
): T[] {
  const data = idl[fieldName];

  if (!_.isArray(data)) {
    throw new Error(`IDL incorrectly formatted - ${fieldName} field missing or not an array`);
  }

  // Type assertion is safe here because we've validated it's an array
  const typedData = data as T[];

  if (validator && !validator(typedData)) {
    throw new Error(`IDL validation failed for ${fieldName} field`);
  }

  return typedData;
}

/**
 * Generates the standard file header for auto-generated files
 *
 * @param additionalImports - Optional additional import statements
 * @returns The file header as an array of lines
 */
export function generateFileHeader(additionalImports: string[] = []): string[] {
  return [
    "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.",
    ...additionalImports,
    ...(additionalImports.length > 0 ? [""] : []),
  ];
}

/**
 * Reads and parses an IDL JSON file for a given program
 *
 * @param programName - The name of the program (e.g., "sablier_lockup")
 * @returns The parsed IDL object
 * @throws Error if the file cannot be read or parsed
 */
export function readIdlFile(programName: string): BaseIdl {
  const idlPath = join(IDL_DIR, `${programName}.json`);

  try {
    const content = readFileSync(idlPath, { encoding: "utf-8" });
    const parsed = JSON.parse(content) as BaseIdl;

    // Basic validation of IDL structure
    if (!parsed.address || !parsed.metadata || !parsed.metadata.name) {
      throw new Error("Invalid IDL structure - missing required fields");
    }

    return parsed;
  } catch (error) {
    throw new Error(`Failed to read IDL file for ${programName}: ${error}`);
  }
}

/**
 * Writes generated TypeScript content to a file
 *
 * @param content - The TypeScript content to write
 * @param programName - The program name for the output file
 * @param suffix - The file suffix (e.g., "_errors", "_structs")
 */
export function writeGeneratedFile(content: string, programName: string, suffix: string): void {
  const outputPath = join(TYPES_DIR, `${programName}${suffix}.ts`);
  writeFileSync(outputPath, content);
}

/* -------------------------------------------------------------------------- */
/*                            COMMAND LINE HANDLING                          */
/* -------------------------------------------------------------------------- */

/**
 * Standard main function for codegen scripts
 *
 * @param generatorFn - Function that generates code for a single program
 * @param successMessage - Message to display on success
 */
export function createMainFunction(generatorFn: (programName: string) => void, successMessage: string) {
  return function main() {
    // Parse command line arguments
    const programName = process.argv[2] as ProgramName | "all" | undefined;

    // Validate program name
    validateProgramName(programName);

    // Execute code generation
    executeCodegen(programName, generatorFn, successMessage);
  };
}

/**
 * Executes a code generation function for the specified program(s)
 *
 * @param programName - The program name or "all"
 * @param generatorFn - Function that generates code for a single program
 * @param successMessage - Message to display on success
 */
export function executeCodegen(
  programName: ProgramName | "all",
  generatorFn: (programName: string) => void,
  successMessage: string,
): void {
  if (programName === "all") {
    // Generate for all supported programs
    generatorFn(ProgramNameEnum.Lockup);
    generatorFn(ProgramNameEnum.MerkleInstant);
    console.log(`‚úÖ Successfully generated ${successMessage} for all programs\n`);
  } else {
    // Generate for a specific program
    generatorFn(programName);
    console.log(`‚úÖ Successfully generated ${successMessage} for ${programName}\n`);
  }
}

/**
 * Validates command line arguments for codegen scripts
 *
 * @param programName - The program name from command line arguments
 * @throws Process exit if validation fails
 */
export function validateProgramName(programName: string | undefined): asserts programName is ProgramName | "all" {
  if (!programName || !VALID_PROGRAMS.includes(programName)) {
    console.error(`‚ùå Missing or Invalid program name: ${programName}`);
    console.error(`üìã Valid options: ${VALID_PROGRAMS.join(", ")}`);
    process.exit(1);
  }
}
