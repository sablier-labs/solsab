/**
 * @file Shared utilities for code generation scripts
 *
 * This module contains common functionality used by both codegen-errors.ts and codegen-structs.ts
 * to avoid duplication and ensure consistency across code generation scripts.
 */

import { readFileSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import type { Idl } from "@coral-xyz/anchor";
import _ from "lodash";
import { ProgramName as ProgramNameEnum } from "../../../lib/enums";
import type { ProgramName } from "../../../lib/types";

/* -------------------------------------------------------------------------- */
/*                                 CONSTANTS                                  */
/* -------------------------------------------------------------------------- */

/** Root directory of the project */
export const ROOT_DIR = join(__dirname, "..", "..", "..");

/** Directory containing Anchor-generated IDL JSON files */
export const IDL_DIR = join(ROOT_DIR, "target", "idl");

/** Directory for generated TypeScript files */
export const TYPES_DIR = join(ROOT_DIR, "target", "types");

/** Valid program names that can be processed by codegen scripts */
export const VALID_PROGRAMS = ["all", ..._.values(ProgramNameEnum)];

/* -------------------------------------------------------------------------- */
/*                               CORE UTILITIES                              */
/* -------------------------------------------------------------------------- */

/**
 * Extracts a specific field from an IDL and validates it with type safety
 *
 * @template T - The expected type of the array elements
 * @param programName - The name of the Solana program (e.g., "sablier_lockup")
 * @param fieldName - The field to extract (e.g., "errors", "types")
 * @param validator - Optional validation function for the extracted data
 * @returns The extracted and validated data with proper typing
 * @throws Error if the field is missing, not an array, or validation fails
 */
export function extractIdlField<T = unknown>(
  programName: string,
  fieldName: keyof Idl,
  validator?: (data: T[]) => boolean,
): T[] {
  // Read and parse the IDL file
  const idl = readIdlFile(programName);

  // Extract the specified field
  const data = idl[fieldName];

  if (!_.isArray(data)) {
    throw new Error(`IDL incorrectly formatted - ${fieldName} field missing or not an array`);
  }

  // Type assertion is safe here because we've validated it's an array
  const typedData = data as T[];

  if (validator && !validator(typedData)) {
    throw new Error(`IDL validation failed for ${fieldName} field`);
  }

  return typedData;
}

/**
 * Generates the standard file header for auto-generated files
 *
 * @param additionalImports - Optional additional import statements
 * @returns The file header as an array of lines
 */
export function generateFileHeader(additionalImports: string[] = []): string[] {
  return [
    "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.",
    ...additionalImports,
    ...(additionalImports.length > 0 ? [""] : []),
  ];
}

/**
 * Reads and parses an IDL JSON file for a given program
 *
 * @param programName - The name of the program (e.g., "sablier_lockup")
 * @returns The parsed IDL object
 * @throws Error if the file cannot be read or parsed
 */
export function readIdlFile(programName: string): Idl {
  const idlPath = join(IDL_DIR, `${programName}.json`);

  try {
    const content = readFileSync(idlPath, { encoding: "utf-8" });
    const parsed = JSON.parse(content) as Idl;

    // Basic validation of IDL structure
    if (!parsed.address || !parsed.metadata || !parsed.metadata.name) {
      throw new Error("Invalid IDL structure - missing required fields");
    }

    return parsed;
  } catch (error) {
    throw new Error(`Failed to read IDL file for ${programName}: ${error}`);
  }
}

/**
 * Writes generated TypeScript content to a file
 *
 * @param content - The TypeScript content to write
 * @param programName - The program name for the output file
 * @param suffix - The file suffix (e.g., "_errors", "_structs")
 */
export function writeGeneratedFile(content: string, programName: string, suffix: string): void {
  const outputPath = join(TYPES_DIR, `${programName}${suffix}.ts`);
  writeFileSync(outputPath, content);
}

/* -------------------------------------------------------------------------- */
/*                            COMMAND LINE HANDLING                          */
/* -------------------------------------------------------------------------- */

/**
 * Standard main function for codegen scripts
 *
 * @param generatorFn - Function that generates code for a single program
 * @param successMessage - Message to display on success
 */
export function createMainFunction(generatorFn: (programName: string) => void, successMessage: string) {
  return function main() {
    // Parse command line arguments
    const programName = process.argv[2] as ProgramName | "all" | undefined;

    // Validate program name
    validateProgramName(programName);

    // Execute code generation
    executeCodegen(programName, generatorFn, successMessage);
  };
}

/**
 * Executes a code generation function for the specified program(s)
 *
 * @param programName - The program name or "all"
 * @param generatorFn - Function that generates code for a single program
 * @param successMessage - Message to display on success
 */
function executeCodegen(
  programName: ProgramName | "all",
  generatorFn: (programName: string) => void,
  successMessage: string,
): void {
  if (programName === "all") {
    // Generate for all supported programs
    generatorFn(ProgramNameEnum.Lockup);
    generatorFn(ProgramNameEnum.MerkleInstant);
    console.log(`‚úÖ Successfully generated ${successMessage} for all programs\n`);
  } else {
    // Generate for a specific program
    generatorFn(programName);
    console.log(`‚úÖ Successfully generated ${successMessage} for ${programName}\n`);
  }
}

/**
 * Validates command line arguments for codegen scripts
 *
 * @param programName - The program name from command line arguments
 * @throws Process exit if validation fails
 */
export function validateProgramName(programName: string | undefined): asserts programName is ProgramName | "all" {
  if (!programName || !VALID_PROGRAMS.includes(programName)) {
    console.error(`‚ùå Missing or Invalid program name: ${programName}`);
    console.error(`üìã Valid options: ${VALID_PROGRAMS.join(", ")}`);
    process.exit(1);
  }
}
